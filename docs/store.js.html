<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Source: store.js</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="",baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body class="light" data-theme="light"><div class="sidebar-container"><div class="sidebar" id="sidebar"><a href="/" class="sidebar-title sidebar-title-anchor">Home</a><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="8HwLqVhM1dDjcMabv8SpM"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="Indexer.html">Indexer</a></div><div class="sidebar-section-children"><a href="Store.html">Store</a></div><div class="sidebar-section-children"><a href="Walker.html">Walker</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="0PMWnAasRmDqTiIcVcXWn"><div>Tutorials</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="tutorial-why-not-ocfl.html">why-not-ocfl</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="jR9OUvzJeUc3BefZhw7gM"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#Credentials">Credentials</a></div><div class="sidebar-section-children"><a href="global.html#Transfer">Transfer</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#dark-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">store.js</h1></header><article><pre class="prettyprint source lang-js"><code>import { Bucket } from "./s3.js";
import * as nodePath from "path";
import hasha from "hasha";
import { Indexer } from "./indexer.js";
import mime from "mime-types";
import lodashPkg from "lodash";
const { isUndefined, isString, isArray, chunk, uniqBy, flattenDeep } = lodashPkg;

const specialFiles = ["nocfl.inventory.json", "nocfl.identifier.json"];

/**
 * A transfer Object
 * @typedef {Object} Transfer
 * @property {String} localPath - the path to the file locally that you want to upload to the item folder
 * @property {String} json - a JSON object to store in the file directly
 * @property {String} content - some content to store in the file directly
 * @property {String} target - the target name for the file; this will be set relative to the item path
 * @property {Boolean} registerFile=true - whether the file should be registered in ro-crate-metadata.json.
 *  The file will be registered in the hasPart property of the root dataset if there isn't already an entry for the file.
 * @property {Boolean} version=false - whether the file should be versioned. If true, the existing file will be copied
 *  to ${file}.v${date as ISO String}.{ext} before the new version is uploaded to the target name
 */

/**
 * An AWS Credentials Object
 * @typedef {Object} Credentials
 * @property {String} bucket - the AWS bucket to connect to
 * @property {String} accessKeyId - the AWS accessKey
 * @property {String} secretAccessKey - the AWS secretAccessKey
 * @property {String} region - the AWS region
 * @property {String} [endpoint] - the endpoint URL when using an S3 like service (e.g. Minio)
 * @property {Boolean} [forcePathStyle] - whether to force path style endpoints (required for Minio and the like)
 */

/** Class representing an S3 store. */
export class Store {
    /**
     * Interact with an object in an S3 bucket.
     * @since 1.17.0
     * @constructor
     * @param {Object} params
     * @param {Credentials} params.credentials - the AWS credentials to use for the connection
     * @param {string} params.prefix -  define a path prefix
     * @param {string} params.type - the class / type of the item being operated on - must match: ^[a-z,A-Z][a-z,A-Z,0-9,_]+$
     * @param {string} params.id - the id of the item being operated on - must match: ^[a-z,A-Z][a-z,A-Z,0-9,_]+$
     * @param {number} [params.splay=1] - the number of characters (from the start of the identifer) when converting the id to a path
     */
    constructor({
        domain = undefined,
        prefix = undefined,
        className,
        type,
        id,
        credentials,
        splay = 1,
    }) {
        if (!id) throw new Error(`Missing required property: 'id'`);
        if (!domain &amp;&amp; !prefix) throw new Error(`Missing required property: 'domain' || 'prefix'`);
        if (!className &amp;&amp; !type)
            throw new Error(`Missing required property: 'className' || 'type'`);
        if (!credentials) throw new Error(`Missing required property: 'credentials'`);

        const requiredProperties = ["bucket", "accessKeyId", "secretAccessKey", "region"];
        requiredProperties.forEach((property) => {
            if (!credentials[property]) {
                throw new Error(`Missing required property: '${property}'`);
            }
        });

        if (!isString(id)) {
            throw new Error(`The 'id' must be a string`);
        }

        if (!isUndefined &amp;&amp; !isString(className)) {
            throw new Error(`The 'className' must be a string`);
        }
        if (!isUndefined &amp;&amp; !isString(type)) {
            throw new Error(`The 'type' must be a string`);
        }
        if (!isUndefined &amp;&amp; !isString(domain)) {
            throw new Error(`The 'domain' must be a string`);
        }
        if (!isUndefined &amp;&amp; !isString(prefix)) {
            throw new Error(`The 'prefix' must be a string`);
        }

        if (!id.match(/^[a-z,A-Z][a-z,A-Z,0-9,_]+$/)) {
            throw new Error(
                `The identifier doesn't match the allowed format: ^[a-z,A-Z][a-z,A-Z,0-9,_]+$`
            );
        }
        if (!isUndefined &amp;&amp; !className.match(/^[a-z,A-Z][a-z,A-Z,0-9,_]+$/)) {
            throw new Error(
                `The 'className' doesn't match the allowed format: ^[a-z,A-Z][a-z,A-Z,0-9,_]+$`
            );
        }
        if (!isUndefined &amp;&amp; !type.match(/^[a-z,A-Z][a-z,A-Z,0-9,_]+$/)) {
            throw new Error(
                `The 'type' doesn't match the allowed format: ^[a-z,A-Z][a-z,A-Z,0-9,_]+$`
            );
        }

        this.credentials = credentials;
        this.bucket = new Bucket(credentials);
        this.id = id;
        this.type = type ? type : className;
        this.prefix = prefix ? prefix : domain;
        this.objectPath = `${this.prefix.toLowerCase()}/${this.type.toLowerCase()}/${id.slice(
            0,
            splay
        )}/${id}`;

        // @deprecate v2
        this.domain = this.prefix;
        this.itemPath = this.objectPath;
        this.className = this.type;
        //

        this.splay = splay;
        this.roCrateFile = nodePath.join(this.objectPath, "ro-crate-metadata.json");
        this.inventoryFile = nodePath.join(this.objectPath, "nocfl.inventory.json");
        this.identifierFile = nodePath.join(this.objectPath, "nocfl.identifier.json");
        this.roCrateSkeleton = {
            "@context": [
                "https://w3id.org/ro/crate/1.1/context",
                {
                    "@vocab": "http://schema.org/",
                },
                {
                    txc: "https://purl.archive.org/textcommons/terms#",
                },
                {
                    "@base": null,
                },
            ],
            "@graph": [
                {
                    "@id": "ro-crate-metadata.json",
                    "@type": "CreativeWork",
                    conformsTo: {
                        "@id": "https://w3id.org/ro/crate/1.1",
                    },
                    about: {
                        "@id": "./",
                    },
                    identifier: "ro-crate-metadata.json",
                },
                {
                    "@id": "./",
                    "@type": ["Dataset"],
                    name: "My Research Object Crate",
                },
            ],
        };
        this.indexer = new Indexer({ credentials });
    }

    /**
     * Check whether the item exists in the storage.
     * @deprecated Use exists from version 2
     * @see {@link exists}
     * @return {Boolean}
     */
    async itemExists() {
        if (await this.bucket.pathExists({ path: this.identifierFile })) {
            return true;
        }
        return false;
    }

    /**
     * Check whether the object exists in the storage.
     * @since 1.17.0
     * @return {Boolean}
     */
    async exists() {
        if (await this.bucket.pathExists({ path: this.identifierFile })) {
            return true;
        }
        return false;
    }

    /**
     * Check whether the path exists in the storage.
     * @deprecated use fileExists from version 2
     * @see {@link fileExists}
     * @param {Object} params
     * @param {String} params.path - the path of the file to check - this is relative to the item root
     * @return {Boolean}
     */
    async pathExists({ path }) {
        let target = nodePath.join(this.itemPath, path);
        return await this.bucket.pathExists({ path: target });
    }

    /**
     * Check whether the path exists in the storage.
     * @since 1.17.0
     * @param {Object} params
     * @param {String} params.path - the path of the file to check - this is relative to the item root
     * @return {Boolean}
     */
    async fileExists({ path }) {
        let target = nodePath.join(this.objectPath, path);
        return await this.bucket.pathExists({ path: target });
    }

    /**
     * Get the item path.
     * @deprecated use getObjectPath from version 2
     * @see {@link getObjectPath}
     * @return {String}
     */
    getItemPath() {
        return this.objectPath;
    }

    /**
     * Get the path of the object in the storage.
     * @since 1.17.0
     * @return {String}
     */
    getObjectPath() {
        return this.objectPath;
    }

    /**
     * Get the item identifier.
     * @deprecated use getObjectIdentifier from version 2
     * @see {@link getObjectIdentifier}
     * @return {Object}
     */
    async getItemIdentifier() {
        return await this.getJSON({ target: "nocfl.identifier.json" });
    }

    /**
     * Get the object identifier.
     * @since 1.17.0
     * @return {Object}
     */
    async getObjectIdentifier() {
        return await this.getJSON({ target: "nocfl.identifier.json" });
    }

    /**
     * Get the item inventory file.
     * @deprecated use getObjectInventory from version 2
     * @see {@link getObjectInventory}
     * @return {Object}
     */
    async getItemInventory() {
        return await this.getJSON({ target: "nocfl.inventory.json" });
    }

    /**
     * Get the object inventory file.
     * @since 1.17.0
     * @return {Object}
     */
    async getObjectInventory() {
        return await this.getJSON({ target: "nocfl.inventory.json" });
    }

    /**
     * Return the file stat.
     * @param {Object} params
     * @param {String} params.path - the path of the file to stat- this is relative to the item root
     * @return {Boolean}
     */
    async stat({ path }) {
        let target = nodePath.join(this.objectPath, path);
        return await this.bucket.stat({ path: target });
    }

    /**
     * Create the item in the storage.
     * @deprecated use createObject from version 2
     * @see {@link createObject}
     * @return {Boolean}
     */
    async createItem() {
        if (await this.itemExists()) {
            throw new Error(`An item with that identifier already exists`);
        }
        let roCrateFileHash = hasha(JSON.stringify(this.roCrateSkeleton));
        await this.bucket.put({
            target: this.roCrateFile,
            json: this.roCrateSkeleton,
        });

        await this.bucket.put({
            target: this.inventoryFile,
            json: { content: { "ro-crate-metadata.json": roCrateFileHash } },
        });

        await this.bucket.put({
            target: this.identifierFile,
            json: {
                id: this.id,
                className: this.className,
                domain: this.domain,
                itemPath: this.itemPath,
                splay: this.splay,
            },
        });

        // patch the index file
        await this.indexer.patchIndex({
            action: "PUT",
            domain: this.domain,
            className: this.className,
            id: this.id,
            splay: this.splay,
        });
    }

    /**
     * Create the object in the storage.
     * @since 1.17.0
     * @return {Boolean}
     */
    async createObject() {
        if (await this.exists()) {
            throw new Error(`An item with that identifier already exists`);
        }
        let roCrateFileHash = hasha(JSON.stringify(this.roCrateSkeleton));
        await this.bucket.put({
            target: this.roCrateFile,
            json: this.roCrateSkeleton,
        });

        await this.bucket.put({
            target: this.inventoryFile,
            json: { content: { "ro-crate-metadata.json": roCrateFileHash } },
        });

        await this.bucket.put({
            target: this.identifierFile,
            json: {
                id: this.id,
                type: this.type,
                prefix: this.prefix,
                objectPath: this.objectPath,
                splay: this.splay,
            },
        });

        // patch the index file
        await this.indexer.patchIndex({
            action: "PUT",
            prefix: this.prefix,
            type: this.type,
            id: this.id,
            splay: this.splay,
        });
    }

    /**
     * Get a file from the item on the storage.
     * @param {Object} params
     * @param {String} params.localPath - the local path where you want to download the file to
     * @param {String} params.target - the file on the storage, relative to the item path, that you want to download
     */
    async get({ localPath, target }) {
        target = nodePath.join(this.objectPath, target);
        return await this.bucket.get({ target, localPath });
    }

    /**
     * Get a JSON file from the item on the storage.
     * @param {Object} params
     * @param {String} params.localPath - the local path where you want to download the file to
     * @param {String} params.target - the file on the storage, relative to the item path, that you want to download
     */
    async getJSON({ localPath, target }) {
        return JSON.parse(await this.get({ localPath, target }));
    }

    /**
     * Get file versions.
     * @param {Object} params
     * @param {String} params.target - the file whose versions to retrieve
     * @return {Array} - versions of the specified file ordered newest to oldest. The file as named (ie without a version
     *   string will be the first - newest - entry)
     */
    async listFileVersions({ target }) {
        target = nodePath.basename(target, nodePath.extname(target));
        let files = await this.bucket.listObjects({
            prefix: nodePath.join(this.objectPath, target),
        });
        let versions = files.Contents.map((c) => c.Key).sort();
        versions = [...versions.slice(1), versions[0]].reverse();
        return versions.map((v) => v.replace(`${this.getObjectPath()}/`, ""));
    }

    /**
     * Get a presigned link to the file.
     * @param {Object} params
     * @param {String} params.target - the file on the storage, relative to the item path, that you want the url for
     * @param {String} params.download - get link that can be used to trigger a direct file download
     */
    async getPresignedUrl({ target, download }) {
        target = nodePath.join(this.objectPath, target);
        return await this.bucket.getPresignedUrl({ target, download });
    }

    /**
     * Put a file into the item on the storage.
     * @param {Object} params
     * @param {String} params.localPath - the path to the file locally that you want to upload to the item folder
     * @param {String} params.json - a JSON object to store in the file directly
     * @param {String} params.content - some content to store in the file directly
     * @param {String} params.target - the target name for the file; this will be set relative to the item path
     * @param {Boolean} params.registerFile=true - whether the file should be registered in ro-crate-metadata.json.
     *  The file will be registered in the hasPart property of the root dataset if there isn't already an entry for the file.
     * @param {Boolean} params.version=false - whether the file should be versioned. If true, the existing file will be copied
     *  to ${file}.v${date as ISO String}.{ext} before the new version is uploaded to the target name
     * @param {String} params.mimetype - the mimetype of the file. If not defined, the library will try to determine it.
     * @param {Transfer[]} params.batch - an array of objects defining content to put into the store where the params
     *  are as for the single case. Uploads will be run 5 at a time.
     */
    async put({
        localPath = undefined,
        json = undefined,
        content = undefined,
        target = undefined,
        registerFile = true,
        version = false,
        mimetype = undefined,
        batch = [],
    }) {
        if (!(await this.exists())) {
            throw new Error(`The item doesn't exist`);
        }

        if (!target &amp;&amp; !batch.length) {
            // nothing to do
            return;
        }

        if (target &amp;&amp; !batch.length) {
            batch = [{ localPath, json, content, target, registerFile, version, mimetype }];
        }

        let files = [];
        putFile = putFile.bind(this);

        // upload the batch
        let chunks = chunk(batch, 5);
        for (let chunk of chunks) {
            let transfers = chunk.map((params) => {
                params.registerFile = params.registerFile ?? true;
                return putFile(params);
            });
            let uploadedFiles = await Promise.all(transfers);
            files.push(uploadedFiles);
        }

        files = flattenDeep(files);

        // update the nocfl inventory
        await this.__updateInventory({ files });

        // register files in the crate file as required
        files = files.filter((f) => f.registerFile);
        await this.registerFilesInCrateMetadata({ files });

        async function putFile(params) {
            let { localPath, json, content, target, registerFile, mimetype, version } = params;
            if (specialFiles.includes(target)) {
                throw new Error(
                    `You can't upload a file called '${target} as that's a special file used by the system`
                );
            }
            let newContentHash;
            if (localPath) {
                newContentHash = await hasha.fromFile(localPath, { algorithm: "sha512" });
            } else if (json) {
                newContentHash = hasha(JSON.stringify(json), { algorithm: "sha512" });
            } else {
                newContentHash = hasha(content, { algorithm: "sha512" });
            }

            let uploadedFiles = [];
            try {
                if (version) {
                    let result = await this.__version({ sourceHash: newContentHash, target });
                    if (result) uploadedFiles.push({ ...params, ...result });
                }
                await this.bucket.put({
                    localPath,
                    json,
                    content,
                    target: nodePath.join(this.getObjectPath(), target),
                });
                uploadedFiles.push({ ...params, target, hash: newContentHash });
            } catch (error) {
                console.log(error);
            }
            return uploadedFiles;
        }
    }

    /**
     * Copy a file into the item from another part of the storage. This capability is specifically to support using
     *  different locations in the bucket for working data and repository data where the repository data might contain versioned
     *  copies of the working data.
     * @param {Object} params
     * @param {String} params.source - the source file to be copied - this must be a full path to the file inside the bucket
     * @param {String} params.target - the target location to copy the source file to; this is relative to the object path
     * @param {Boolean} params.registerFile=true - whether the file should be registered in ro-crate-metadata.json.
     *  The file will be registered in the hasPart property of the root dataset if there isn't already an entry for the file.
     * @param {Boolean} params.version=false - whether the file should be versioned. If true, the existing file will be copied
     *  to ${file}.v${date as ISO String}.{ext} before the new version is uploaded to the target name
     * @param {Transfer[]} params.batch - an array of objects defining content to put into the store where the params
     *  are as for the single case. Uploads will be run 5 at a time.
     */
    async copy({
        source = undefined,
        target = undefined,
        registerFile = true,
        version = false,
        batch = [],
    }) {
        if (!(await this.exists())) {
            throw new Error(`The item doesn't exist`);
        }

        if (!target &amp;&amp; !batch.length) {
            // nothing to do
            return;
        }

        if (target &amp;&amp; !batch.length) {
            batch = [{ source, target, registerFile, version }];
        }

        let files = [];
        copyFile = copyFile.bind(this);

        let chunks = chunk(batch, 5);
        for (let chunk of chunks) {
            let transfers = chunk.map((params) => {
                params.registerFile = params.registerFile ?? true;
                return copyFile(params);
            });
            let uploadedFiles = await Promise.all(transfers);
            files.push(uploadedFiles);
        }

        // update the nocfl inventory
        files = flattenDeep(files);
        await this.__updateInventory({ files });

        // register files in the crate file as required
        files = files.filter((f) => f.registerFile);
        await this.registerFilesInCrateMetadata({ files });

        async function copyFile(params) {
            let { source, target, version } = params;
            if (specialFiles.includes(target)) {
                throw new Error(
                    `You can't upload a file called '${target} as that's a special file used by the system`
                );
            }

            let uploadedFiles = [];
            let sourceHash = await this.hashTarget({ target: source, relative: false });
            try {
                if (version) {
                    let result = await this.__version({ sourceHash, target });
                    if (result) uploadedFiles.push({ ...params, ...result });
                }
                await this.bucket.copy({ source, target: `${this.getObjectPath()}/${target}` });
                uploadedFiles.push({ ...params, target, hash: sourceHash });
            } catch (error) {
                console.log(error);
            }
            return uploadedFiles;
        }
    }

    /**
     * Register a set of files in ro-crate-metadata.json. If no files are defined the method will register all files that are not special files.
     * @since 1.18.0
     * @param {String[]} [files] - if provided, the array of file names to be registered, relative to the root of the object.
     */
    async registerFilesInCrateMetadata({ files = [] }) {
        // get the crate file
        let crate = await this.getJSON({ target: "ro-crate-metadata.json" });

        if (!files.length) {
            files = await this.listResources();
            files = files
                .map((f) => f.Key)
                .filter((f) => ![...specialFiles, "ro-crate-metadata.json"].includes(f));
        }

        for (let file of files) {
            crate["@graph"] = await this.__updateCrateMetadata({
                graph: crate["@graph"],
                add_target: file.target,
                mimetype: file.mimetype,
            });
        }

        // save the crate file back
        await this.bucket.put({
            target: this.roCrateFile,
            json: crate,
        });
    }

    /**
     * Remove a file or files from an item in the storage. Files will also be removed from the hasPart property of the root dataset.
     * @param {Object} params
     * @param {String|Array.&lt;String>} [params.target] - the target name for the file or array of target files; this will be set relative to the item path
     * @param {String} [params.prefix] - file prefix; this will be set relative to the item path
     */
    async delete({ target = undefined, prefix = undefined }) {
        if (specialFiles.includes(target)) {
            throw new Error(
                `You can't delete a file called '${target} as that's a special file used by the system`
            );
        }

        let crate = await this.getJSON({ target: "ro-crate-metadata.json" });

        if (target) {
            if (!isString(target) &amp;&amp; !isArray(target)) {
                throw new Error(`target must be a string or array of strings`);
            }
            if (isString(target)) target = [target];
            let keys = target.map((t) => nodePath.join(this.objectPath, t));
            await this.bucket.delete({ keys });
            crate["@graph"] = await this.__updateCrateMetadata({
                graph: crate["@graph"],
                remove_keys: target,
            });
        } else if (prefix) {
            if (!isString(prefix)) {
                throw new Error(`prefix must be a string`);
            }
            await this.bucket.delete({ prefix: nodePath.join(this.objectPath, prefix) });
            crate["@graph"] = await this.__updateCrateMetadata({
                graph: crate["@graph"],
                remove_prefix: prefix,
            });
        }
        // update the ro crate file
        await this.bucket.put({
            target: this.roCrateFile,
            json: crate,
        });
    }

    /**
     * Delete the item.
     * @deprecated use removeObject from version 2
     * @see {@link removeObject}
     */
    async deleteItem() {
        if (!(await this.itemExists())) {
            throw new Error(`The item doesn't exist`);
        }
        await this.bucket.delete({ prefix: `${this.itemPath}/` });

        // patch the index file
        await this.indexer.patchIndex({
            action: "DELETE",
            domain: this.domain,
            className: this.className,
            id: this.id,
            splay: this.splay,
        });
    }

    /**
     * Delete the object in the storage.
     * @since 1.17.0
     */
    async removeObject() {
        await this.bucket.delete({ prefix: `${this.objectPath}/` });

        // patch the index file
        await this.indexer.patchIndex({
            action: "DELETE",
            prefix: this.prefix,
            type: this.type,
            id: this.id,
            splay: this.splay,
        });
    }

    /**
     * Recursively walk and list all of the files for the item.
     * @return { String[]} - a list of files
     */
    async listResources() {
        listItemResources = listItemResources.bind(this);
        let resources = await listItemResources({});
        resources = resources.map((r) => {
            r.Key = r.Key.replace(`${this.objectPath}/`, "");
            return r;
        });
        return resources;

        async function listItemResources({ continuationToken }) {
            let resources = await this.bucket.listObjects({
                prefix: `${this.objectPath}/`,
                continuationToken,
            });
            if (resources.NextContinuationToken) {
                return [
                    ...resources.Contents,
                    ...(await listResources(resources.NextContinuationToken)),
                ];
            } else {
                return resources.Contents;
            }
        }
    }

    /**
     * Resolve the full path of a file in the storage
     * @since 1.17.0
     * @param {String} params.path - the path to the file relative to the object root that it to be resolved
     * @return {String} - the full path to a file
     */
    resolvePath({ path }) {
        return `${this.objectPath}/${path}`;
    }

    /**
     * Calculate the SHA512 hash of a file in storage
     * @param {Object} params
     * @param {String} params.target - the file on the storage, relative to the item path, that is to be hashed
     * @return {String} - the hash of the file or undefined
     */
    async hashTarget({ target, relative = true }) {
        if (relative) target = nodePath.join(this.objectPath, target);

        const stream = await this.bucket.stream({ target });
        if (stream) {
            let hash = await hasha.fromStream(stream, { algorithm: "sha512" });
            return hash;
        }
    }

    /**
     * Update the hasPart property of the root dataset.
     * @private
     * @param {Object} params
     * @param {Object} params.graph - crate['@graph']
     * @param {String} params.add_target - the name of a file to add to the hasPart property
     * @param {Array.&lt;String>} params.remove_keys - an array of keys and entities to remove from the graph
     * @param {String} params.remove_prefix - a string prefix to match on and remove from the graph
     * @return {Object} the graph
     */
    async __updateCrateMetadata({
        graph,
        add_target = undefined,
        remove_keys = [],
        remove_prefix = "",
        mimetype = undefined,
    }) {
        // find the root dataset
        let rootDescriptor = graph.filter(
            (e) => e["@id"] === "ro-crate-metadata.json" &amp;&amp; e["@type"] === "CreativeWork"
        )[0];
        let rootDataset = graph.filter((e) => e["@id"] === rootDescriptor.about["@id"])[0];
        if (!rootDataset) {
            console.log(`${this.objectPath}/ro-crate-metadata.json DOES NOT have a root dataset`);
            return;
        }

        // ensure hasPart defined and is array
        if (!rootDataset.hasPart) rootDataset.hasPart = [];
        if (!isArray(rootDataset.hasPart)) rootDataset.hasPart = [rootDataset.hasPart];

        if (add_target &amp;&amp; add_target !== "ro-crate-metadata.json") {
            const target = add_target;
            // we don't register the ro crate file

            // update the hasPart property
            rootDataset.hasPart.push({ "@id": target });
            rootDataset.hasPart = uniqBy(rootDataset.hasPart, "@id");

            // add a File entry to the crate is none there already
            let fileEntry = graph.filter((e) => e["@id"] === target);
            if (!fileEntry.length) {
                let stat = await this.stat({ path: target });
                if (!mimetype) mimetype = mime.lookup(target);
                let entity = {
                    "@id": target,
                    "@type": "File",
                    name: target,
                    contentSize: stat.ContentLength,
                    dateModified: stat.LastModified,
                    "@reverse": {
                        hasPart: [{ "@id": "./" }],
                    },
                };
                if (mimetype) entity.encodingFormat = mimetype;
                graph.push(entity);
            }
        } else if (remove_keys.length) {
            let hasPart = rootDataset.hasPart.filter((e) => {
                return !remove_keys.includes(e["@id"]);
            });
            rootDataset.hasPart = hasPart;
            graph = graph.filter((e) => !remove_keys.includes(e["@id"]));
        } else if (remove_prefix) {
            let re = new RegExp(remove_prefix);
            let hasPart = rootDataset.hasPart.filter((e) => !e["@id"].match(re));
            rootDataset.hasPart = hasPart;
            graph = graph.filter((e) => !e["@id"].match(re));
        } else {
            // nothing to do - just return the graph
            return graph;
        }

        graph = graph.map((e) => {
            if (e["@id"] === rootDescriptor.about["@id"]) return rootDataset;
            return e;
        });
        return graph;
    }

    /**
     * Update the file inventory.
     * @private
     * @param {Object} params
     * @param {Object[]} params.files - an array of file objects and hashes to be added to the inventory
     * @return {String[]} - a list of files
     */
    async __updateInventory({ files = [] }) {
        // let inventory = JSON.parse(await this.bucket.get({ target: this.inventoryFile }));
        let inventory = await this.getObjectInventory();
        for (let file of files) {
            inventory.content[file.target] = file.hash;
        }
        await this.bucket.put({
            target: this.inventoryFile,
            json: inventory,
        });
    }

    /**
     * Version a file.
     * @private
     * @param {Object} params
     * @param {String} params.target - the file on the storage, relative to the item path, that is to be versioned
     */
    async __version({ sourceHash, target }) {
        // can't version a target that isn't there
        let exists = await this.fileExists({ path: target });
        if (!exists) return;

        let targetHash = await this.hashTarget({ target });
        if (sourceHash === targetHash) {
            // nothing to do - same file
            return;
        }

        const source = nodePath.join(this.getObjectPath(), target);
        const date = new Date().toISOString();
        const extension = nodePath.extname(target);
        const basename = nodePath.basename(target, extension);
        target = `${basename}.v${date}${extension}`;
        try {
            await this.bucket.copy({ source, target: nodePath.join(this.objectPath, target) });
            return { target, hash: targetHash };
        } catch (error) {
            throw new Error(error.message);
        }
    }
}
</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><a href="/" class="sidebar-title sidebar-title-anchor">Home</a><div class="mobile-nav-links"></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="8HwLqVhM1dDjcMabv8SpM"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="Indexer.html">Indexer</a></div><div class="sidebar-section-children"><a href="Store.html">Store</a></div><div class="sidebar-section-children"><a href="Walker.html">Walker</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="0PMWnAasRmDqTiIcVcXWn"><div>Tutorials</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="tutorial-why-not-ocfl.html">why-not-ocfl</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="jR9OUvzJeUc3BefZhw7gM"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#Credentials">Credentials</a></div><div class="sidebar-section-children"><a href="global.html#Transfer">Transfer</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#dark-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>