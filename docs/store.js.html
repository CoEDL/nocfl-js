<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding favicon -->
    

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    

    <!-- Adding overlay style-->
    


    <title>
      store.js
    </title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-light.css">
    
    <svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path
                    d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z" />
                <path
                    d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z" />
            </g>
        </symbol>
        <symbol id='search-icon' viewBox="0 0 512 512">
            <g>
                <g>
                    <path
                        d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z" />
                </g>
            </g>
            <g>
                <g>
                    <path
                        d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z" />
                </g>
            </g>
        </symbol>
        <symbol id="down-icon" viewBox="0 0 16 16">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd" 
                d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"
            >
            </path>
        </symbol>
    </defs>
</svg>
  </head>

  <body>

    <nav class="navbar" id="navbar">
      <div class="navbar-heading" id="navbar-heading"><a href="index.html"><h2 class="navbar-heading-text">Home</h2></a></div><div class="search-box" id="search-box"><div class="search-box-input-container"><input class="search-box-input" type="text" placeholder="Search..." id="search-box-input" /><svg class="search-icon" alt="search-icon"><use xlink:href="#search-icon"></use></svg></div><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-main-content" id="sidebar-main-content"><div class="accordion collapsed" id="641969" > <h3 class="accordion-heading">Classes<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion collapsed child" id=9010344><div class="accordion-heading child"><a href="Store.html">Store</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Store.html#createItem">createItem</a></li><li data-type='method'><a href="Store.html#delete">delete</a></li><li data-type='method'><a href="Store.html#get">get</a></li><li data-type='method'><a href="Store.html#getItemIdentifier">getItemIdentifier</a></li><li data-type='method'><a href="Store.html#getItemInventory">getItemInventory</a></li><li data-type='method'><a href="Store.html#getItemPath">getItemPath</a></li><li data-type='method'><a href="Store.html#getJSON">getJSON</a></li><li data-type='method'><a href="Store.html#getPresignedUrl">getPresignedUrl</a></li><li data-type='method'><a href="Store.html#itemExists">itemExists</a></li><li data-type='method'><a href="Store.html#listResources">listResources</a></li><li data-type='method'><a href="Store.html#pathExists">pathExists</a></li><li data-type='method'><a href="Store.html#put">put</a></li><li data-type='method'><a href="Store.html#stat">stat</a></li></ul></li></ul> </div><div class="accordion collapsed" id="4953144" > <h3 class="accordion-heading">Global<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="global.html#Transfer">Transfer</a></li></ul> </div>
      

    </nav>
    <div class="navbar-ham" id="navbar-ham">
      <div>
        <div class="first"></div>
        <div class="second"></div>
        <div class="third"></div>
      </div>
    </div>

    <div id="main" class="main-content">
      
      <h1 id='page-title' class="page-title">
        store.js
      </h1>
      

      



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { Bucket } from "./s3.js";
import fsExtra from "fs-extra";
const { createReadStream } = fsExtra;
import crypto from "crypto";
import * as nodePath from "path";
import hasha from "hasha";
import { isString, isUndefined, isArray, chunk } from "lodash";

const specialFiles = ["nocfl.inventory.json", "nocfl.identifier.json"];

/** Class representing an S3 store. */
export class Store {
    /**
     * Interact with a store in an S3 bucket
     * @constructor
     * @param {string} className - the class name of the item being operated on - must match: ^[a-z,A-Z][a-z,A-Z,0-9,_]+$
     * @param {string} id - the id of the item being operated on - must match: ^[a-z,A-Z][a-z,A-Z,0-9,_]+$
     * @param {string} [domain] - provide this to prefix the paths by domain
     * @param {string} credentials.bucket - the AWS bucket to connect to
     * @param {string} credentials.accessKeyId - the AWS accessKey
     * @param {string} credentials.secretAccessKey - the AWS secretAccessKey
     * @param {string} credentials.region - the AWS region
     * @param {string} [credentials.endpoint] - the endpoint URL when using an S3 like service (e.g. Minio)
     * @param {boolean} [credentials.forcePathStyle] - whether to force path style endpoints (required for Minio and the like)
     * @param {number} [splay=1] - the number of characters (from the start of the identifer) when converting the id to a path
     */
    constructor({ domain = undefined, className, id, credentials, splay = 1 }) {
        if (!id) throw new Error(`Missing required property: 'id'`);
        if (!className) throw new Error(`Missing required property: 'className'`);
        if (!credentials) throw new Error(`Missing required property: 'credentials'`);

        const requiredProperties = ["bucket", "accessKeyId", "secretAccessKey", "region"];
        requiredProperties.forEach((property) => {
            if (!credentials[property]) {
                throw new Error(`Missing required property: '${property}'`);
            }
        });

        if (!isString(id)) {
            throw new Error(`The 'id' must be a string`);
        }
        if (!isString(className)) {
            throw new Error(`The 'className' must be a string`);
        }
        if (!isString(domain) &amp;&amp; !isUndefined(domain)) {
            throw new Error(`The 'domain' must be a string`);
        }

        if (!id.match(/^[a-z,A-Z][a-z,A-Z,0-9,_]+$/)) {
            throw new Error(
                `The identifier doesn't match the allowed format: ^[a-z,A-Z][a-z,A-Z,0-9,_]+$`
            );
        }
        if (!className.match(/^[a-z,A-Z][a-z,A-Z,0-9,_]+$/)) {
            throw new Error(
                `The className doesn't match the allowed format: ^[a-z,A-Z][a-z,A-Z,0-9,_]+$`
            );
        }

        this.credentials = credentials;
        this.bucket = new Bucket(credentials);
        this.id = id;
        this.className = className;
        this.domain = domain;
        this.itemPath = domain
            ? `${domain.toLowerCase()}/${className.toLowerCase()}/${id.slice(0, splay)}/${id}`
            : `${className.toLowerCase()}/${id.slice(0, splay)}/${id}`;
        this.roCrateFile = nodePath.join(this.itemPath, "ro-crate-metadata.json");
        this.inventoryFile = nodePath.join(this.itemPath, "nocfl.inventory.json");
        this.identifierFile = nodePath.join(this.itemPath, "nocfl.identifier.json");
        this.roCrateSkeleton = {
            "@context": [
                "https://w3id.org/ro/crate/1.1/context",
                {
                    "@vocab": "http://schema.org/",
                },
                {
                    txc: "https://purl.archive.org/textcommons/terms#",
                },
                {
                    "@base": null,
                },
            ],
            "@graph": [
                {
                    "@id": "ro-crate-metadata.json",
                    "@type": "CreativeWork",
                    conformsTo: {
                        "@id": "https://w3id.org/ro/crate/1.1",
                    },
                    about: {
                        "@id": "./",
                    },
                    identifier: "ro-crate-metadata.json",
                },
            ],
        };
    }

    /**
     * Check whether the item exists in the storage
     * @return {Boolean}
     */
    async itemExists() {
        if (
            await this.bucket.pathExists({
                path: nodePath.join(this.itemPath, "nocfl.inventory.json"),
            })
        ) {
            return true;
        }
        return false;
    }

    /**
     * Get the item path
     * @return {String}
     */
    getItemPath() {
        return this.itemPath;
    }

    /**
     * Get the item identifier
     * @return {Object}
     */
    async getItemIdentifier() {
        return JSON.parse(await this.get({ target: "nocfl.identifier.json" }));
    }

    /**
     * Get the item inventory file
     * @return {Object}
     */
    async getItemInventory() {
        return JSON.parse(await this.get({ target: "nocfl.inventory.json" }));
    }

    /**
     * Check whether the path exists in the storage
     * @param {String} path - the path of the file to check - this is relative to the item root
     * @return {Boolean}
     */
    async pathExists({ path }) {
        let target = nodePath.join(this.itemPath, path);
        return await this.bucket.pathExists({ path: target });
    }

    /**
     * Return the file stat
     * @param {String} path - the path of the file to stat- this is relative to the item root
     * @return {Boolean}
     */
    async stat({ path }) {
        let target = nodePath.join(this.itemPath, path);
        return await this.bucket.stat({ path: target });
    }

    /**
     * Create the item in the storage
     * @return {Boolean}
     */
    async createItem() {
        if (await this.itemExists()) {
            throw new Error(`An item with that identifier already exists`);
        }
        let roCrateFileHash = hasha(JSON.stringify(this.roCrateSkeleton));
        await this.bucket.upload({
            target: this.roCrateFile,
            json: this.roCrateSkeleton,
        });

        await this.bucket.upload({
            target: this.inventoryFile,
            json: { content: { "ro-crate-metadata.json": roCrateFileHash } },
        });

        await this.bucket.upload({
            target: this.identifierFile,
            json: {
                id: this.id,
                className: this.className,
                domain: this.domain,
                itemPath: this.itemPath,
            },
        });
    }

    /**
     * Get a file from the item on the storage
     * @param {String} localPath - the local path where you want to download the file to
     * @param {String} target - the file on the storage, relative to the item path, that you want to download
     */
    async get({ localPath, target }) {
        target = nodePath.join(this.itemPath, target);

        return await this.bucket.download({ target, localPath });
    }

    /**
     * Get a JSON file from the item on the storage
     * @param {String} localPath - the local path where you want to download the file to
     * @param {String} target - the file on the storage, relative to the item path, that you want to download
     */
    async getJSON({ localPath, target }) {
        return JSON.parse(await this.get({ localPath, target }));
    }

    /**
     * Get a presigned link to the file
     * @param {String} target - the file on the storage, relative to the item path, that you want the url for
     */
    async getPresignedUrl({ target, download }) {
        target = nodePath.join(this.itemPath, target);
        return await this.bucket.getPresignedUrl({ target, download });
    }

    /**
     * A transfer Object
     * @typedef {Object} Transfer
     * @property {String} localPath - the path to the file locally that you want to upload to the item folder
     * @property {String} json - a JSON object to store in the file directly
     * @property {String} content - some content to store in the file directly
     * @property {String} target - the target name for the file; this will be set relative to the item path
     */

    /**
     * Put a file into the item on the storage
     * @param {String} localPath - the path to the file locally that you want to upload to the item folder
     * @param {String} json - a JSON object to store in the file directly
     * @param {String} content - some content to store in the file directly
     * @param {String} target - the target name for the file; this will be set relative to the item path
     * @param {Transfer[]} batch - an array of objects defining content to put into the store where the params
     *  are as for the single case. Uploads will be run 5 at a time.
     */
    async put({ localPath, json, content, target, batch = [] }) {
        if (!(await this.itemExists())) {
            throw new Error(`You need to 'createItem' before you can add content to it`);
        }

        transfer = transfer.bind(this);
        if (batch.length) {
            let chunks = chunk(batch, 5);
            for (let chunk of chunks) {
                let transfers = chunk.map((t) => transfer(t));
                await Promise.all(transfers);
            }
        } else {
            await transfer({ localPath, json, content, target });
        }

        async function transfer({ localPath, json, content, target }) {
            if (specialFiles.includes(target)) {
                throw new Error(
                    `You can't upload a file called '${target} as that's a special file used by the system`
                );
            }
            if (localPath) {
                let hash = await sha512(localPath);
                await this.__updateInventory({ target, hash });
            } else if (json) {
                await this.__updateInventory({ target, hash: hasha(JSON.stringify(json)) });
            } else {
                await this.__updateInventory({ target, hash: hasha(content) });
            }
            let s3Target = nodePath.join(this.itemPath, target);
            return await this.bucket.upload({ localPath, json, content, target: s3Target });
        }
    }

    /**
     * Remove a file from an item in the storage
     * @param {String|Array.&lt;String>} [target] - the target name for the file or array of target files; this will be set relative to the item path
     * @param {String} [prefix] - file prefix; this will be set relative to the item path
     */
    async delete({ target = undefined, prefix = undefined }) {
        if (specialFiles.includes(target)) {
            throw new Error(
                `You can't delete a file called '${target} as that's a special file used by the system`
            );
        }

        if (!(await this.itemExists())) {
            throw new Error(`You need to 'createItem' before you can remove content from it`);
        }

        if (target) {
            if (!isString(target) &amp;&amp; !isArray(target)) {
                throw new Error(`target must be a string or array of strings`);
            }
            if (isString(target)) target = [target];
            let keys = target.map((t) => nodePath.join(this.itemPath, t));
            return await this.bucket.removeObjects({ keys });
        } else if (prefix) {
            if (!isString(prefix)) {
                throw new Error(`prefix must be a string`);
            }
            prefix = nodePath.join(this.itemPath, prefix);
            return await this.bucket.removeObjects({ prefix });
        }
    }

    /**
     * Recursively walk and list all of the files for the item
     * @return a list of files
     */
    async listResources() {
        listItemResources = listItemResources.bind(this);
        let resources = await listItemResources({});
        resources = resources.map((r) => {
            r.Key = r.Key.replace(`${this.getItemPath()}/`, "");
            return r;
        });
        return resources;

        async function listItemResources({ continuationToken }) {
            let resources = await this.bucket.listObjects({
                prefix: this.itemPath,
                continuationToken,
            });
            if (resources.NextContinuationToken) {
                return [
                    ...resources.Contents,
                    ...(await listResources(resources.NextContinuationToken)),
                ];
            } else {
                return resources.Contents;
            }
        }
    }

    /**
     * Update the file inventory
     * @private
     * @param {String} target - the file on the storage, relative to the item path
     * @param {String} hash - the hash (checksum) of the file
     * @return a list of files
     */
    async __updateInventory({ target, hash }) {
        let inventory = JSON.parse(await this.bucket.download({ target: this.inventoryFile }));
        inventory.content[target] = hash;
        await this.bucket.upload({
            target: this.inventoryFile,
            json: inventory,
        });
    }
}

const sha512 = (path) =>
    new Promise((resolve, reject) => {
        const hash = crypto.createHash("sha512");
        const rs = createReadStream(path);
        rs.on("error", reject);
        rs.on("data", (chunk) => hash.update(chunk));
        rs.on("end", () => resolve(hash.digest("hex")));
    });
</code></pre>
        </article>
    </section>




    </div>

    <footer class="footer" id="footer">
      
    </footer>

    <script src="scripts/third-party/prettify.js"></script>
    <script src="scripts/third-party/lang-css.js"></script>
    <script type="text/javascript" src="scripts/misc.js"></script>

    <script>prettyPrint();</script>
    <script src="scripts/linenumber.js"></script>
    <script src="scripts/fix-code-block.js"></script>
    <script src="scripts/fix-navbar.js"></script>
    
      <script src="scripts/search.js"></script>
      <script src="scripts/third-party/fuse.js"></script>
      <script>
        var list = [{"title":"Store","link":"<a href=\"Store.html\">Store</a>"},{"title":"Store#createItem","link":"<a href=\"Store.html#createItem\">Store &rtrif; createItem</a>"},{"title":"Store#delete","link":"<a href=\"Store.html#delete\">Store &rtrif; delete</a>"},{"title":"Store#get","link":"<a href=\"Store.html#get\">Store &rtrif; get</a>"},{"title":"Store#getItemIdentifier","link":"<a href=\"Store.html#getItemIdentifier\">Store &rtrif; getItemIdentifier</a>"},{"title":"Store#getItemInventory","link":"<a href=\"Store.html#getItemInventory\">Store &rtrif; getItemInventory</a>"},{"title":"Store#getItemPath","link":"<a href=\"Store.html#getItemPath\">Store &rtrif; getItemPath</a>"},{"title":"Store#getJSON","link":"<a href=\"Store.html#getJSON\">Store &rtrif; getJSON</a>"},{"title":"Store#getPresignedUrl","link":"<a href=\"Store.html#getPresignedUrl\">Store &rtrif; getPresignedUrl</a>"},{"title":"Store#itemExists","link":"<a href=\"Store.html#itemExists\">Store &rtrif; itemExists</a>"},{"title":"Store#listResources","link":"<a href=\"Store.html#listResources\">Store &rtrif; listResources</a>"},{"title":"Store#pathExists","link":"<a href=\"Store.html#pathExists\">Store &rtrif; pathExists</a>"},{"title":"Store#put","link":"<a href=\"Store.html#put\">Store &rtrif; put</a>"},{"title":"Store#stat","link":"<a href=\"Store.html#stat\">Store &rtrif; stat</a>"},{"title":"Transfer","link":"<a href=\"global.html#Transfer\">Transfer</a>"}];
        var options = 
          setupSearch(list, options)
      </script>
    

    

    

    


  </body>

</html>
